var documenterSearchIndex = {"docs":
[{"location":"#ContextVariables.jl-1","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"","category":"section"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"ContextVariables.jl is heavily inspired by contextvars in Python (see also PEP 567).","category":"page"},{"location":"#Tutorial-1","page":"ContextVariables.jl","title":"Tutorial","text":"","category":"section"},{"location":"#Basic-usage-1","page":"ContextVariables.jl","title":"Basic usage","text":"","category":"section"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Context variables can be used to manage task-local states that are inherited to child tasks.  Context variables are created by @contextvar:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"@contextvar cvar1           # untyped, without default\n@contextvar cvar2 = 1       # typed (Int), with default\n@contextvar cvar3::Int      # typed, without default","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Note that running above code in REPL will throw an error because this form work only within a package namespace.  To play with @contextvar in REPL, you can prefix the variable name with global:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> @contextvar global x;","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"warning: Warning\n@contextvar global should be used only for interactive exploration, quick scripting, and testing.  Using @contextvar global inside packages make it impossible to work with serialization-based libraries such as Distributed.","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"You can be get and set the value of context variable with the indexing syntax []","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> x[] = 1;\n\njulia> x[]\n1","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"The value can be unset with delete!:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> delete!(x);\n\njulia> x[]\nERROR: KeyError: key ContextVar(:x) not found","category":"page"},{"location":"#Handling-possibly-unassigned-variables-1","page":"ContextVariables.jl","title":"Handling possibly-unassigned variables","text":"","category":"section"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Use get and set! to handle context variables that may not be assigned:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> get(x)  # returns `nothing`\n\njulia> set!(x, Some(1));  # equivalent to `x[] = 1`\n\njulia> get(x)\nSome(1)\n\njulia> set!(x, nothing);  # equivalent to `delete!(x)`","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"This is useful to rollback a context variable without knowing the current value of it:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"old = get(x)\nx[] = some_value\ndo_something()\nset!(x, old)  # rollback `x` to the previous state (may not be assigned)","category":"page"},{"location":"#Dynamic-scoping-1","page":"ContextVariables.jl","title":"Dynamic scoping","text":"","category":"section"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"with_context can be used to set multiple context variables at once, run a function in this context, and then rollback them to the original state:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> @contextvar global y = 1;\n       @contextvar global z::Int;\n\njulia> function demo1()\n           @show x[]\n           @show y[]\n           @show z[]\n       end;\n\njulia> z[] = 100;\n\njulia> with_context(demo1, x => :a, z => 0);\nx[] = :a\ny[] = 1\nz[] = 0\n\njulia> z[]\n100","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Note that with_context(f, x => nothing, ...) clears the value of x, rather than setting the value of x to nothing.  Use Some(nothing) to set nothing.  Similar caution applies to set_context (see below).","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> with_context(x => Some(nothing), y => nothing, z => nothing) do\n           @show x[]\n           @show y[]\n           @show get(z)\n       end\nx[] = nothing\ny[] = 1\nget(z) = nothing","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Thus,","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"with_context(x => Some(a), y => Some(b), z => nothing) do\n    ...\nend","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"can be used considered as a dynamically scoped version of","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"let x′ = a, y′ = b, z′\n    ...\nend","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Note that with_context(f, var => value, ...) does not rollback the context variables that are not specified by the input:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> with_context(x => :a) do\n           z[] = 0\n       end;\n\njulia> z[]\n0","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Use with_context(f, nothing) to create an empty context and rollback the entire context to the state just before calling it.","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> with_context(nothing) do\n           z[] = 123\n       end;\n\njulia> z[]\n0","category":"page"},{"location":"#Batch-update-1","page":"ContextVariables.jl","title":"Batch update","text":"","category":"section"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Since setting multiple context variables at once is more efficient than setting them sequentially, set_context can be used to set multiple context variables in the current context in one go:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> set_context(x => 1, y => 2, z => 3);\n\njulia> (x[], y[], z[])\n(1, 2, 3)","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"A handle to the snapshot of the current context can be obtained with snapshot_context.  It can be later restored by reset_context.","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> x[]\n1\n\njulia> snapshot = snapshot_context();\n\njulia> x[] = 123;\n\njulia> reset_context(snapshot);\n\njulia> x[]\n1","category":"page"},{"location":"#Concurrent-access-1","page":"ContextVariables.jl","title":"Concurrent access","text":"","category":"section"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"The context is inherited to the child task when the task is created. Thus, changes made after @async/@spawn or changes made in other tasks are not observable:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> function demo2()\n           x0 = x[]\n           x[] += 1\n           (x0, x[])\n       end\n\njulia> with_context(x => 1) do\n           @sync begin\n               t1 = @async demo2()\n               t2 = @async demo2()\n               result = demo2()\n               [result, fetch(t1), fetch(t2)]\n           end\n       end\n3-element Array{Tuple{Int64,Int64},1}:\n (1, 2)\n (1, 2)\n (1, 2)","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"In particular, manipulating context variables using the public API is always data-race-free.","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"warning: Warning\nIf a context variable holds a mutable value, it is a data-race to mutate the value when other threads are reading it.@contextvar local x = [1]  # mutable value\n@sync begin\n    @spawn begin\n        value = x[]        # not a data-race\n        push!(value, 2)    # data-race\n    end\n    @spawn begin\n        value = x[]        # not a data-race\n        @show last(value)  # data-race\n    end\nend","category":"page"},{"location":"#Namespace-1","page":"ContextVariables.jl","title":"Namespace","text":"","category":"section"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Consider packages and modules with the same variable name:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"module PackageA\n    @contextvar x = 1\n    module SubModule\n        @contextvar x = 2\n    end\nend","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"and","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"module PackageB\n    @contextvar x = 3\nend","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"When these packages are loaded, there are three distinct context variables PackageA.x, PackageA.SubModule.x, and PackageB.x that can be manipulated independently.","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"This is simply because @contextvar creates independent variable \"instance\" in each context.  It can be demonstrated easily in the REPL:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> @contextvar global x;\n\njulia> a = x\nMain.x :: ContextVar [4630fcbd-7f5b-4094-916a-f3b33acf4453] (not assigned)\n\njulia> @contextvar global x;\n\njulia> b = x\nMain.x :: ContextVar [f6a7639c-3b33-414e-98bc-504b40a48cb8] (not assigned)\n\njulia> a != b\ntrue\n\njulia> a[] = 1;\n\njulia> b[] = 2;\n\njulia> a\nMain.x :: ContextVar [4630fcbd-7f5b-4094-916a-f3b33acf4453] => 1\n\njulia> b\nMain.x :: ContextVar [f6a7639c-3b33-414e-98bc-504b40a48cb8] => 2","category":"page"},{"location":"#Function-local-context-variables-1","page":"ContextVariables.jl","title":"Function-local context variables","text":"","category":"section"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Context variables local in a function can be created by prefixing the variable name with local:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> function demo3()\n           @contextvar local x = 1\n           x[]\n       end;\n\njulia> demo3()\n1","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"If this context variable is mutated, it \"remembers\" the history of the calls made in the same task:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> function demo4(n)\n           @contextvar local x = 1\n           @show x[]\n           x[] += 1\n           n > 1 ? demo4(n - 1) : nothing\n       end;\n\njulia> demo4(2)\nx[] = 1\nx[] = 2\n\njulia> demo4(1)\nx[] = 3","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Since the local context variables cannot be accessed outside of the function, the only way to remove it from the storage outside of the function is reset_context:","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> reset_context()\n\njulia> demo4(1)\nx[] = 1","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Like normal context variables, the local context variables propagate to child tasks.","category":"page"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"julia> demo4(1)\nx[] = 2\n\njulia> with_context() do  #  with_context required for IRTools used for PoC\n           @sync @async demo4(1)\n       end;\nx[] = 3\n\njulia> with_context() do\n           @sync @async demo4(1)\n       end;\nx[] = 3\n\njulia> demo4(1)\nx[] = 3","category":"page"},{"location":"#Reference-1","page":"ContextVariables.jl","title":"Reference","text":"","category":"section"},{"location":"#","page":"ContextVariables.jl","title":"ContextVariables.jl","text":"Modules = [ContextVariables]\nPrivate = false","category":"page"},{"location":"#ContextVariables.ContextVar","page":"ContextVariables.jl","title":"ContextVariables.ContextVar","text":"ContextVar{T}\n\nContext variable type.  This is the type of the object var created by @contextvar var.  This acts as a reference to the value stored in a task-local.  The macro @contextvar is the only public API to construct this object.\n\nwarning: Warning\nIt is unspecified if this type is concrete or not. It may be changed to an abstract type and/or include more type parameters in the future.\n\n\n\n\n\n","category":"type"},{"location":"#Base.get-Union{Tuple{ContextVar{T}}, Tuple{T}} where T","page":"ContextVariables.jl","title":"Base.get","text":"get(var::ContextVar{T}) -> Union{Some{T},Nothing}\n\nReturn Some(value) if value is assigned to var.  Return nothing if unassigned.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{ContextVar{T}}, Tuple{T}} where T","page":"ContextVariables.jl","title":"Base.getindex","text":"getindex(var::ContextVar{T}) -> value::T\n\nReturn the value assigned to var.  Throw a KeyError if unassigned.\n\n\n\n\n\n","category":"method"},{"location":"#ContextVariables.reset_context-Tuple{ContextVariables.ContextSnapshot}","page":"ContextVariables.jl","title":"ContextVariables.reset_context","text":"reset_context(snapshot::ContextSnapshot)\nreset_context()\n\nRest the entire context of the current task to the state at which snapshot is obtained via snapshot_context.\n\n\n\n\n\n","category":"method"},{"location":"#ContextVariables.set!-Union{Tuple{T}, Tuple{ContextVar{T},Union{Nothing, Some}}} where T","page":"ContextVariables.jl","title":"ContextVariables.set!","text":"set!(var::ContextVar, Some(value))\nset!(var::ContextVar, nothing)\n\nSet the value of context variable var to value or delete it.\n\n\n\n\n\n","category":"method"},{"location":"#ContextVariables.set_context-Tuple{Vararg{Pair{#s16,B} where B where #s16<:ContextVar,N} where N}","page":"ContextVariables.jl","title":"ContextVariables.set_context","text":"set_context(var1 => value1, var2 => value2, ...)\nset_context(pairs)\nset_context(snapshot::ContextSnapshot)\n\nEquivalent to var1[] = value1, var2[] = value2, and so on.  The second form expect an iterable of pairs of context variable and values.  This function is more efficient than setting individual context variables sequentially.  Like with_context, nothing value means to clear the context variable and Some is always unwrapped.\n\nA \"snapshot\" of the context returned from snapshot_context can be specified as an input (the third form).\n\nExamples\n\njulia> using ContextVariables\n\njulia> @contextvar global x\n       @contextvar global y;\n\njulia> set_context(x => 1, y => 2)\n\njulia> x[]\n1\n\njulia> y[]\n2\n\njulia> set_context([x => 10, y => 20])\n\njulia> x[]\n10\n\njulia> y[]\n20\n\n\n\n\n\n","category":"method"},{"location":"#ContextVariables.snapshot_context-Tuple{}","page":"ContextVariables.jl","title":"ContextVariables.snapshot_context","text":"snapshot_context() -> snapshot::ContextSnapshot\n\nGet a snapshot of a context that can be passed to reset_context to rewind all changes in the context variables.\n\n\n\n\n\n","category":"method"},{"location":"#ContextVariables.with_context-Tuple{Any,Vararg{Any,N} where N}","page":"ContextVariables.jl","title":"ContextVariables.with_context","text":"with_context(f, var1 => value1, var2 => value2, ...)\nwith_context(f, pairs)\n\nRun f in a context with given values set to the context variables.  Variables specified in this form are rolled back to the original value when with_context returns.  It act like a dynamically scoped let.  If nothing is passed as a value, corresponding context variable is cleared; i.e., it is unassigned or takes the default value.  Use Some(value) to set value if value can be nothing.\n\nwith_context(f, nothing)\n\nRun f in a new empty context.  All variables are rewind to the original values when with_context returns.\n\nNote that\n\nvar2[] = value2\nwith_context(var1 => value1) do\n    @show var2[]  # shows value2\n    var3[] = value3\nend\n@show var3[]  # shows value3\n\nand\n\nvar2[] = value2\nwith_context(nothing) do\n    var1[] = value1\n    @show var2[]  # shows default (or throws)\n    var3[] = value3\nend\n@show var3[]  # does not show value3\n\nare not equivalent.\n\n\n\n\n\n","category":"method"},{"location":"#ContextVariables.@contextvar-Tuple{Any}","page":"ContextVariables.jl","title":"ContextVariables.@contextvar","text":"@contextvar [local|global] var[::T] [= default]\n\nDeclare a context variable named var.  The type constraint ::T and the default value = default are optional.  If the default value is given without the type constraint ::T, its type T = typeof(default) is used.\n\n@contextvar without local and global prefixes can only be used at the top-level scope of packages with valid UUID.\n\nwarning: Warning\nContext variables declared with global does not work with Distributed.\n\nExamples\n\nTop-level context variables needs to be declared in a package:\n\nmodule MyPackage\n@contextvar cvar1\n@contextvar cvar2 = 1\n@contextvar cvar3::Int\nend\n\nContext variables can be declared in local scope by using local prefix:\n\njulia> using ContextVariables\n\njulia> function demo()\n           @contextvar local x = 1\n           function f()\n               x[] += 1\n               return x[]\n           end\n           return f()\n       end;\n\njulia> demo()\n2\n\nTo use @contextvar in a non-package namespace like REPL, prefix the variable with global:\n\njulia> using ContextVariables\n\njulia> @contextvar global X;\n\njulia> X[] = 1;\n\njulia> X[]\n1\n\n\n\n\n\n","category":"macro"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Modules = [ContextVariables]\nPublic = false","category":"page"},{"location":"internals/#ContextVariables.genkey-Tuple{Module,Symbol}","page":"Internals","title":"ContextVariables.genkey","text":"genkey(__module__::Module, varname::Symbol) -> UUID\n\nGenerate a stable UUID for a context variable __module__.$varname.\n\n\n\n\n\n","category":"method"},{"location":"internals/#ContextVariables.merge_ctxvars-Tuple{Any,Any}","page":"Internals","title":"ContextVariables.merge_ctxvars","text":"merge_ctxvars(ctx::Union{Nothing,T}, kvs) -> ctx′:: Union{Nothing,T}\n\nwarning: Warning\nThis is not a public API.  This documentation is for making it easier to experiment with different implementations of the context variable storage backend, by monkey-patching it at run-time.\n\nThe first argument ctx is either nothing or a dict-like object of type T where its keytype is UUID and valtype is Any.  The second argument kvs is an iterable of Pair{UUID,<:Union{Some,Nothing}} values.  Iterable kvs must have length.\n\nIf ctx is nothing and kvs is non-empty, merge_ctxvars creates a new instance of T. If ctx is not nothing, it returns a shallow-copy ctx′ of ctx where k => v is inserted to ctx′ for each k => Some(v) in kvs and k is deleted from ctx′ for each k => nothing in kvs.\n\n\n\n\n\n","category":"method"}]
}
